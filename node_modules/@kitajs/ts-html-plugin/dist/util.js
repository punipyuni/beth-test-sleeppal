"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isJsx = isJsx;
exports.recursiveDiagnoseJsxElements = recursiveDiagnoseJsxElements;
exports.diagnoseJsxElement = diagnoseJsxElement;
exports.isSafeAttribute = isSafeAttribute;
exports.getSafeAttribute = getSafeAttribute;
exports.proxyObject = proxyObject;
const tslib_1 = require("tslib");
const typescript_1 = tslib_1.__importDefault(require("typescript"));
const Errors = tslib_1.__importStar(require("./errors"));
const UPPERCASE = /[A-Z]/;
const ESCAPE_HTML_REGEX = /^(\w+\.)?(escapeHtml|e|escape)/i;
/** If the node is a JSX element or fragment */
function isJsx(ts, node) {
    return (ts.isJsxElement(node) || ts.isJsxFragment(node) || ts.isJsxSelfClosingElement(node));
}
function recursiveDiagnoseJsxElements(ts, node, typeChecker, original) {
    ts.forEachChild(node, function loopSourceNodes(node) {
        // Recurse through children first
        ts.forEachChild(node, loopSourceNodes);
        // Adds children to the array
        if (isJsx(ts, node)) {
            // Diagnose the node
            diagnoseJsxElement(ts, node, typeChecker, original);
        }
    });
    // Filter out duplicates
    for (let i = 0; i < original.length; i++) {
        for (let j = i + 1; j < original.length; j++) {
            if (original[i].start === original[j].start &&
                original[i].length === original[j].length) {
                original.splice(j--, 1);
            }
        }
    }
}
function diagnostic(node, error, category) {
    return {
        category: typescript_1.default.DiagnosticCategory[category],
        messageText: Errors[error].message,
        code: Errors[error].code,
        file: node.getSourceFile(),
        length: node.getWidth(),
        start: node.getStart()
    };
}
function diagnoseJsxElement(ts, node, typeChecker, diagnostics) {
    // Validations that does not applies to fragments or serlf closing elements
    if (ts.isJsxElement(node)) {
        // Script tags should be ignored
        if (node.openingElement.tagName.getText() === 'script') {
            return;
        }
        const safeAttribute = getSafeAttribute(node.openingElement);
        // Safe mode warnings
        if (safeAttribute && node.children) {
            if (
            // Empty element
            node.children.length === 0 ||
                // Only text elements
                (node.children.length === 1 && node.children[0].kind === ts.SyntaxKind.JsxText)) {
                diagnostics.push(diagnostic(safeAttribute, 'UnusedSafe', 'Warning'));
                return;
            }
            for (const exp of node.children) {
                if (
                // JSX Element inside safe
                ts.isJsxElement(exp) ||
                    // Element is using safe with escapeHtml
                    (ts.isJsxExpression(exp) && exp.expression?.getText().match(ESCAPE_HTML_REGEX))) {
                    diagnostics.push(diagnostic(safeAttribute, 'DoubleEscape', 'Error'));
                    continue;
                }
                // Warn on unnecessary safe attributes
                if (ts.isJsxExpression(exp) &&
                    // has inner expression
                    exp.expression) {
                    // gets this expression or array of sub expressions
                    const expressions = getNodeExpressions(exp.expression) || [exp.expression];
                    // at least one jsx inside another jsx with safe
                    if (expressions.some((inner) => ts.isJsxElement(inner))) {
                        diagnostics.push(diagnostic(safeAttribute, 'DoubleEscape', 'Error'));
                        continue;
                    }
                    // all of them must be safe
                    if (expressions.every((inner) => isSafeAttribute(ts, typeChecker.getTypeAtLocation(inner), typeChecker, inner))) {
                        diagnostics.push(diagnostic(safeAttribute, 'UnusedSafe', 'Warning'));
                    }
                }
            }
            return;
        }
    }
    // If this expression does not have children, we can ignore it
    // for example it could be a self closing element
    if (!node.children) {
        return;
    }
    // Look for expressions
    for (const exp of node.children) {
        if (!ts.isJsxExpression(exp)) {
            continue;
        }
        // Should always have an expression
        if (!exp.expression) {
            continue;
        }
        diagnoseExpression(ts, exp.expression, typeChecker, diagnostics, ts.isJsxElement(node) && !!node.openingElement.tagName.getText().match(UPPERCASE));
    }
    return;
}
function diagnoseExpression(ts, node, typeChecker, diagnostics, isComponent) {
    // Unwrap parenthesis
    if (ts.isParenthesizedExpression(node)) {
        node = node.expression;
    }
    // Ignores JSX elements as they are already diagnosed by the loopChildNodes
    if (isJsx(ts, node)) {
        return;
    }
    const expressions = getNodeExpressions(node);
    // ternary or binary expressions should be evaluated on each side
    if (expressions) {
        for (const inner of expressions) {
            diagnoseExpression(ts, inner, typeChecker, diagnostics, isComponent);
        }
        return;
    }
    const type = typeChecker.getTypeAtLocation(node);
    // Safe can be ignored
    if (isSafeAttribute(ts, type, typeChecker, node)) {
        return;
    }
    // Anything other than a identifier should be diagnosed
    if (!ts.isIdentifier(node)) {
        let hadJsx = false;
        for (const tag of node.getChildren()) {
            if (!isJsx(ts, tag)) {
                continue;
            }
            hadJsx = true;
            diagnoseJsxElement(ts, tag, typeChecker, diagnostics);
        }
        // If root JSX element found inside array, diagnose it,
        // otherwise let the diagnostic pass
        if (hadJsx) {
            return;
        }
    }
    // Switch between component and element xss errors
    if (isComponent || ts.isJsxFragment(node)) {
        diagnostics.push(diagnostic(node, 'ComponentXss', 'Error'));
    }
    else {
        diagnostics.push(diagnostic(node, 'Xss', 'Error'));
    }
}
function isSafeAttribute(ts, type, checker, node) {
    // Nothing to do if type cannot be resolved
    if (!type) {
        return true;
    }
    // Any type is never safe
    if (type.flags & ts.TypeFlags.Any) {
        return false;
    }
    if (type.aliasSymbol) {
        // Allows JSX.Element
        if (node &&
            type.aliasSymbol.escapedName === 'Element' &&
            // @ts-expect-error - Fast way of checking
            type.aliasSymbol.parent?.escapedName === 'JSX' &&
            // Only allows in .map(), other method calls or the expression itself
            (ts.isCallExpression(node) || ts.isIdentifier(node))) {
            return true;
        }
        // Allows Html.Children
        if (type.aliasSymbol.escapedName === 'Children' &&
            // @ts-expect-error - When using export namespace X {} and export default X, parent.escapedName
            // ends up as the original namespace name, not the quoted export name.
            (type.aliasSymbol.parent?.escapedName === 'Html' ||
                // @ts-expect-error - When using export as namespace X, parent.escapedName ends up
                // as a complete (without resolving symlinks) quoted import path to its original file.
                type.aliasSymbol.parent?.escapedName.endsWith('@kitajs/html/index"') ||
                // This is needed because of the resolved path of the parent if is installed with pnpm is a symlink
                // that ts resolves to the original file path, so the path is not related to the node_modules but instead
                // is absolute to the file system (this is only here because of the monorepo setup, it is not needed when used as a package)
                (process.env.KITA_TS_HTML_PLUGIN_TESTING === 'true' &&
                    // @ts-expect-error - When using export as namespace X, parent.escapedName ends up
                    type.aliasSymbol.parent?.escapedName.endsWith('packages/html/index"')))) {
            return true;
        }
    }
    // Union types should be checked recursively
    if (type.isUnionOrIntersection()) {
        return type.types.every((innerType) => isSafeAttribute(ts, innerType, checker, node));
    }
    // For Array or Promise, we check the type of the first generic
    if (checker.isArrayType(type) || type.symbol?.escapedName === 'Promise') {
        return isSafeAttribute(ts, type.resolvedTypeArguments?.[0], checker, node);
    }
    const text = node.getText();
    // manual unsafe variables should not pass
    if (text.startsWith('unsafe')) {
        return false;
    }
    // We allow literal string types here, as if they have XSS content,
    // the user has explicitly written it
    if (
    // Non string types cannot have XSS values
    !(type.flags & ts.TypeFlags.String) &&
        // Objects may have toString() overridden
        !(type.flags & ts.TypeFlags.Object)) {
        return true;
    }
    if (
    // Variables starting with safe are suppressed
    text.startsWith('safe') ||
        // Starts with a call to a escapeHtml function name
        text.match(ESCAPE_HTML_REGEX)) {
        return true;
    }
    return false;
}
function getSafeAttribute(element) {
    for (const attribute of element.attributes.properties) {
        if (attribute.getText() === 'safe') {
            return attribute;
        }
    }
    return undefined;
}
function proxyObject(obj) {
    const proxy = Object.create(null);
    for (const k of Object.keys(obj)) {
        const x = obj[k];
        // @ts-expect-error - JS runtime trickery which is tricky to type tersely
        proxy[k] = (...args) => x.apply(obj, args);
    }
    return proxy;
}
/**
 * Returns more than one node if the node is a binary expression or a conditional
 * expression
 */
function getNodeExpressions(node) {
    // Checks operators
    if (typescript_1.default.isBinaryExpression(node)) {
        // Ignores operations which results in a boolean
        if (isBooleanBinaryOperatorToken(node.operatorToken)) {
            return [];
        }
        // Diagnose both sides since both sides can be executed, e.g:
        // a empty string in the left side will execute the right side
        return [node.left, node.right];
    }
    // Checks the inner expression
    if (typescript_1.default.isConditionalExpression(node)) {
        // ignore node.condition because its value will never be rendered
        return [node.whenFalse, node.whenFalse];
    }
    return undefined;
}
function isBooleanBinaryOperatorToken(operator) {
    switch (operator.kind) {
        case typescript_1.default.SyntaxKind.EqualsEqualsEqualsToken:
        case typescript_1.default.SyntaxKind.EqualsEqualsToken:
        case typescript_1.default.SyntaxKind.ExclamationEqualsEqualsToken:
        case typescript_1.default.SyntaxKind.ExclamationEqualsToken:
        case typescript_1.default.SyntaxKind.GreaterThanToken:
        case typescript_1.default.SyntaxKind.GreaterThanEqualsToken:
        case typescript_1.default.SyntaxKind.LessThanEqualsToken:
        case typescript_1.default.SyntaxKind.LessThanToken:
        case typescript_1.default.SyntaxKind.InstanceOfKeyword:
        case typescript_1.default.SyntaxKind.InKeyword:
            return true;
    }
    return false;
}
//# sourceMappingURL=util.js.map